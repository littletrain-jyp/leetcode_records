记录一下自己的刷题路线。

***
- 2023年4月18日 ： 开始第一轮刷题，顺序参照[代码随想录](https://www.programmercarl.com/)，**开始数组**
    - [x] 704. 二分查找
    - [x] 35. 搜索插入位置
    - [x] 34. 在排序数组中查找元素的第一个和最后一个位置
    - [ ] 69. x 的平方根
    - [ ] 367. 有效的完全平方数
- 2023年4月19日：
    - [x] 27 移除元素
    - [x] 26 删除排序数组中的重复项
- 2023年4月20日：
    - [x] 283 移动零
    - [x] 844 比较含退格的字符串
    - [x] 977 有序数组的平方
- 2023年4月22日：
    - [x] 209 长度最小的子数组 
    - [x] 904 水果成篮
    - [x] 76 最小覆盖子串
- 2023年5月9日：**开始链表**
    - [x] 203 移除链表元素
- 2023年5月16日：
    - [x] 707 设计链表
    - [x] 206 反转链表（双指针、递归法）
    - [x] 24 两两交换链表的节点（需要加头节点，返回时head.next）
    - [x] 19 移除倒数第n个节点（双指针，注意要让快指针多走一格，这样慢指针能到倒数第n+1个位置）
    - [x] 面试题02 07 相交链表的节点（双指针 后对齐）
    - [x] 142 链表环检测
- 2023年5月17日： **开始哈希表**
    - [x] 哈希表的基础知识 
    - [x] 242 有效的字母异位词（用长度26的数组做哈希表； 用defaultdict做哈希表）
    - [x] 383 赎金信
    - [x] 49 字母异位词分组（对字符串进行排序，将其作为key，则可以用哈希表进行处理）
    - [x] 438 找到字符串中所有字母异位词(暴力解法：逐个遍历找到相同长度的子串然后排序比较；采用滑动窗口+哈希，滑动窗口来维护一个哈希数组，这样不用针对每个窗口重新排序处理，优化耗时)
    - [x] 349 两个数组的交集
    - [x] 350 两个数组的交集2
    - [x] 202 快乐数
    - [x] 1 两数之和
    - [x] 454 四数相加2 (将4组数分成两组，一组存在hashmap中，另一组进行查询对比)
    - [x] 15 三数之和 （先进行排序，然后固定i，left为i+1,right为最后，开始遍历；） 两数之和不能用双指针是因为要求返回的是索引，不能排序，如果返回的是数值，那么就可以双指针了。
    - [x] 18 四数之和(类似于三数之和，同样双指针。不过不是和为0，而是给了target，所以剪枝条件要少1)时间复杂度O(n^3)
- 2023年5月18日：**开始字符串**
    - [x] 344 反转字符串 (双指针)
    - [x] 541 反转字符串2 (正常模拟)
    - [x] 05 替换空格 (扩充数组+从后往前):如果从前往后则每次要多移动,n^2了
    - [x] 151 反转字符串中的单词 (去除多余空格不仅包括去除前后还有去除中间的)
    - [x] 58 左旋转字符串 (先整体旋转+2个局部旋转 O(n))
- 2023年5月19日 
    - [x] 28 实现substr (**kmp算法**)
    - [x] 459 重复子串(kmp 因为kmp可以找到最长的相同前后缀子串，所以重复n次的前缀表)
    **字符串结束**
-2023年5月22日 **开始栈和队列**
    - [x] 232 用栈实现队列
-2023年5月23日
    - [x] 225 用队列实现栈（deque双向队列： 双队列；单队列）注意和232的区别之处
    - [x] 20 有效的括号 （栈实现）
    - [x] 1047 删除重复字母 （栈实现；**双指针**）
    - [x] 150 逆波兰表达式求值 （栈实现）
    - [x] 239 滑动窗口最大值 （**单调队列**）单调队列用途：求解滑动窗口类的区间最值题目。核心思想：比你强还比你小的选手出现了你就可以退役了。
- 2023年5月24日
    - [x] 347 前k个高频元素 （**哈希表+堆排序** 注意是小顶堆，一直维持k个大小。如果超过了，就把目前最小的头节点pop掉。）
- 2023年5月25日 **开始二叉树**
    - [x] 144 前序遍历（递归、迭代（栈实现、先进右、再进左）、迭代统一框架）
    - [x] 145 后序遍历（递归、迭代（栈实现、先中再右再左最后反转）、迭代统一框架）
    - [x] 94 中序遍历 （递归、迭代（栈实现、先访问节点到底再处理节点将其放进结果集）、迭代统一框架）
- 2023年5月30日
    - [x] 102 层序遍历（从上到下， 从左到右）
    - [x] 107 层次遍历（反转层序遍历）
    - [x] 199 二叉树的右视图(层序遍历，bfs)
    - [x] 637 二叉树的层平均值(层序遍历，bfs)
    - [x] 429 N叉树的层序遍历(层序遍历，bfs)
    - [x] 515 在每个树行中寻找最大值(层序遍历，bfs)
    - [x] 116 填充每个节点的下一个右侧节点指针
    - [x] 117 填充每个节点的下一个右侧节点指针2
    - [x] 104 二叉树的最大深度
    - [x] 111 二叉树的最小深度
- 2023年5月31日
    - [x] 226 翻转二叉树（递归、深搜、广搜）
- 2023年6月1日
    - [x] 101 对称二叉树（递归解法，注意比较的是不是同一个树的左右节点，而是内侧和外侧； 层序遍历； 递归）
    - [x] 100 相同二叉树
- 2023年6月2日
    - [x] 104 二叉树的最大深度
    - [x] 559 n叉树的最大深度
    - [x] 111 二叉树的最小深度
    - [x] 222 完全二叉树的最小深度（递归：必然一个是满二叉树一个是完全二叉树，可以利用满二叉树的节点数量公式）
    - [x] 110 平衡二叉树（每个节点的左右子树高度差不超过1）
    - [x] 257 二叉树的所有路径
- 2023年6月14日
    - [x] 404 左叶子之和
    - [x] 513 找左下角叶子节点的值（回溯、层序遍历）
    - [x] 112 路径之和（回溯）
    - [x] 113 路径总和2
- 2023年6月20日
    - [x] 105 前序和中序构造树
    - [x] 106 中序和后序构造树
    - [x] 654 最大二叉树
- 2023年6月21日
    - [x] 617 合并二叉树
- 2023年7月03日
    - [x] 700 二叉搜索树中的搜索
    - [x] 98 验证二叉搜索树（二叉搜索树的中序遍历是递增数组；不能仅通过比较左右节点和根节点的值，因为根节点大于左子树的最大值，所以需要记录一个最值；递归；迭代）
- 2023年7月04日
    - [x] 530 二叉搜索树的最小绝对差（中序遍历递增数组，递归；递归中使用pre；迭代中使用pre）
    - [x] 501 二叉搜索树中的众数（迭代中使用pre，只有二叉树中使用pre，因为其可以直接在树上进行比较，也不用栈的辅助）
    - [x] 236 二叉树最近邻祖先（递归，后序遍历，明白结果如何一步一步返回，从下往上）
- 2023年7月05日
    - [x] 235 二叉搜索树的最近邻祖先（递归，迭代，从下至上）
    
    
    
    